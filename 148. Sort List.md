## 题目：
https://leetcode.com/problems/sort-list/
## 思路：

分成两个linklist(876) + 归并排序（linkelist21）

**方法一**
```
时间复杂度：O(nlogn)，其中 n 是链表的长度。

空间复杂度：O(logn)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间。
```
**方法二**
```

```

## 答案：
**方法一**
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        
        # 用快慢指针分成两部分(876)
        dummy = ListNode(-1)
        dummy.next = head
        slow, fast = dummy, dummy
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
        # 找到左右部分, 把左部分最后置空
        mid = slow.next
        slow.next = None
        # 递归下去
        left_list = self.sortList(head)
        right_list = self.sortList(mid)
        # 合并
        return self.merge(left_list, right_list)
    # 21
    def merge(self, left_list, right_list):
        dummy = ListNode(-1)
        cur = dummy

        while left_list and right_list:
            if left_list.val <= right_list.val:
                cur.next = left_list
                left_list= left_list.next
                cur = cur.next
            else:
                cur.next = right_list
                right_list = right_list.next
                cur = cur.next
        if left_list:
            cur.next = left_list
        if right_list:
            cur.next = right_list
        return dummy.next


   
```
