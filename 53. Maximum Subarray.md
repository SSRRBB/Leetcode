## 题目：53. Maximum Subarray

https://leetcode.com/problems/maximum-subarray/

Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

A subarray is a contiguous part of an array.

Example 1:
```
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```
Example 2:
```
Input: nums = [1]
Output: 1
```
Example 3:
```
Input: nums = [5,4,-1,7,8]
Output: 23
``` 

Constraints:
```
1 <= nums.length <= 105
-104 <= nums[i] <= 104
```

## 答案：
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        if not nums:
            return 0
        dp = [0 for _ in range(len(nums))] ##1. 确定dp数组(dp table)以及下标的含义！！！！！：表示以 nums[i] 结尾的连续子数组的最大和。
        dp[0] = nums[0] ## 3.dp数组如何初始化
        for i in range(1, len(nums)):  #2&4确定递推公式;遍历顺服
            if dp[i - 1] >= 0:
                dp[i] = dp[i - 1] + nums[i]
            else:
                dp[i] = nums[i]
        return max(dp)
```

```python
################(把递推公式合起来写)
        if not nums:
            return 0

        dp = [0 for _ in range(len(nums))]
        dp[0] = nums[0]
        res = dp[0]
        for i in range(1, len(nums)):
            dp[i] = max(dp[i - 1] + nums[i], nums[i])   # 更新dp[i]
            res = max(res, dp[i])  # 更新全局最大值
        return res
```

## 思路：

![a](https://github.com/SSRRBB/Leetcode/blob/main/Images/430.png)
