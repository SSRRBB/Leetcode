## 题目
Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.

You must solve this problem without using the library's sort function.


Example 1:
```
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
```
Example 2:
```
Input: nums = [2,0,1]
Output: [0,1,2]
```
## 思路
**方法一**
计数排序（counting sorting）,基于值的排序。
时间复杂度：o(n+range),所以有可能range很大或者不可数。所以一般用基于对比的排序，例如快排
计数排序（counting sorting)还需要额外空间储存额外数组（颜色出现次数）
![p](https://github.com/SSRRBB/Leetcode/blob/main/Images/23.png)


**方法二**
# partition
![p](https://github.com/SSRRBB/Leetcode/blob/main/Images/24.png)
![p](https://github.com/SSRRBB/Leetcode/blob/main/Images/25.png)
![p](https://github.com/SSRRBB/Leetcode/blob/main/Images/26.png)

# 第一次是0，1 分开（左边 < 1,右边>=1）
# 第二次是1，2分开（左边< 1, 右边>= 1）

## 答案
**方法一**
```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        #时间复杂度 O(n + range)
        #[1, 0, 2, 0, 2]
        #统计每种颜色出现的次数
        #0-2； 1-1； 2-2；
        #根据统计结果覆盖原数组
        
        if nums is None:
            return
        # 一共三个颜色，存放每个颜色出现次数
        color_cnts = [0] * 3
        # 遍历所有颜色，记录每个颜色出现的次数
        for num in nums:
            color_cnts[num] += 1
        # 根据每个颜色出现的次数，从左到右填充0， 1， 2三种颜色
        index = 0
        for i in range(len(color_cnts)):
            cnt = color_cnts[i]
            while cnt > 0:
                nums[index] = i
                cnt -= 1
                index +=1 
```


**方法二**
```python

```

**方法三**
```python

```
