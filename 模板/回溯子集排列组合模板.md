# 回溯DFS; 子集，组合，排列
```
回溯法
一般情况下，看到题目要求「所有可能的结果」，而不是「结果的个数」，我们就知道需要暴力搜索所有的可行解了，可以用「回溯法」。
「回溯法」实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就「回溯」返回，尝试别的路径。
回溯法是一种算法思想，而递归是一种编程方法，回溯法可以用递归来实现。
```
```
时间复杂度== 方案总数*构造每个方案的时间：子集或组合:O(n*Ckn) & O(2^n* n);  排列 O(n！* n) 

空间复杂度：O(n)。
除答案数组以外，递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度。
```
*******
1. 正规写法 :正规写法对应了**全局共享一个 path 的写法，每次添加到 res 中，需要深度拷贝。python中是需要 copy.deepcopy(path)**
C++ 的 vector 的 push_back() 函数，本身就是深度拷贝。另外由于是全局的 path，因此每次需要对 path 进行 push 和 pop 操作，

2. 简单写法: 每次新建 path，使用的是产生一个新数组 path + [s[:i]]. 这样好处是方便：不同的路径使用的是不同的 path，**a.因此不需要 path.pop() 操作；b. 而且 res.append(path) 的时候不用深度拷贝一遍 path**
## 子集或者组合
*******
其实**子集也是一种组合问题**，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的,

那么既然是无序，取过的元素不会重复取，写回溯算法的时候，**for就要从startIndex开始，而不是从0开始！**

什么时候for可以从0开始呢？求**排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合**
*******
## 排列
*******
此时可以感受出排列问题与子集或者组合的不同：

每层都是从0开始搜索而不是startIndex

需要used数组记录path里都放了哪些元素了(或者直接优化为判断新的元素是否已经在path里面)
*******
![a](https://github.com/SSRRBB/Leetcode/blob/main/Images/361.png)
![a](https://github.com/SSRRBB/Leetcode/blob/main/Images/362.png)
![a](https://github.com/SSRRBB/Leetcode/blob/main/Images/363.png)
![a](https://github.com/SSRRBB/Leetcode/blob/main/Images/364.png)
![a](https://github.com/SSRRBB/Leetcode/blob/main/Images/365.png)
