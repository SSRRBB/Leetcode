# 回溯DFS; 子集，组合，排列
```
回溯法
一般情况下，看到题目要求「所有可能的结果」，而不是「结果的个数」，我们就知道需要暴力搜索所有的可行解了，可以用「回溯法」。
「回溯法」实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就「回溯」返回，尝试别的路径。
回溯法是一种算法思想，而递归是一种编程方法，回溯法可以用递归来实现。
```
```
时间复杂度== 方案总数*构造每个方案的时间：子集或组合:O(n*Ckn) & O(2^n* n);  排列 O(n！* n) 

空间复杂度：O(n)。
除答案数组以外，递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度。
```
*******
1. 正规写法 :正规写法对应了**全局共享一个 path 的写法，每次添加到 res 中，需要深度拷贝。python中是需要 copy.deepcopy(path)**
C++ 的 vector 的 push_back() 函数，本身就是深度拷贝。另外由于是全局的 path，因此每次需要对 path 进行 push 和 pop 操作，

2. 简单写法: 每次新建 path，使用的是产生一个新数组 path + [s[:i]]. 这样好处是方便：不同的路径使用的是不同的 path，**a.因此不需要 path.pop() 操作；b. 而且 res.append(path) 的时候不用深度拷贝一遍 path**
*******
![a](https://github.com/SSRRBB/Leetcode/blob/main/Images/361.png)
![a](https://github.com/SSRRBB/Leetcode/blob/main/Images/362.png)
![a](https://github.com/SSRRBB/Leetcode/blob/main/Images/363.png)
![a](https://github.com/SSRRBB/Leetcode/blob/main/Images/364.png)
![a](https://github.com/SSRRBB/Leetcode/blob/main/Images/365.png)
