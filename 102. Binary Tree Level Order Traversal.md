## 题目：


## 思路：

## 答案：
**## 单队列**
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        ## 单队列
        if not root:
            return []
        
        # step 1把第一层的节点放在队列中
        queue = collections.deque([root])
        result = []
        # step 2 队列非空
        while queue:
            result.append([node.val for node in queue])
            print(result)
            #step 3 把上一层的节点pop出，并append下一层的节点
            for _ in range(len(queue)):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return result


```
**## 单队列  level[] 写法**
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        ## 单队列  level[] 写法
        if not root:
            return []
        
        # step 1把第一层的节点放在队列中
        queue = collections.deque([root])
        result = []
        # step 2 队列非空
        while queue:
            level = []
            #step 3 把上一层的节点pop出，并append下一层的节点
            for _ in range(len(queue)):
                node = queue.popleft()
                level.append(node.val)
                print(level)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            result.append(level)
        return result


```
**## 双队列写法**
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
         ## 双队列写法
        if not root:
            return []

        queue = [root]
        results = []
        while queue:
            next_queue = []
            results.append([node.val for node in queue])
            for node in queue:
                if node.left:
                    next_queue.append(node.left)
                if node.right:
                    next_queue.append(node.right)
            queue = next_queue
        return results

```
**DummyNode 写法**
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        ## DummyNode 写法
        if not root:
            return []

        queue = collections.deque([root, None])
        res, level = [], []
        while queue:
            node = queue.popleft()
            if node is None:
                res.append(level)
                level = []
                if queue:
                    queue.append(None)
                continue
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        return res


```
