## 题目：
https://leetcode.com/problems/merge-sorted-array/

## 思路：
**法一**
```
套用快速排序复杂度
时间复杂度：(n+m)log(n +m)
空间复杂度：平均情况为 O(log(m+n))
```
**法二merge sort**
```
时间复杂度：O(m+n)O。
指针移动单调递增，最多移动 m+n次，因此时间复杂度为 O(m+n)。

空间复杂度：O(m+n)。
需要建立长度为 m+n的中间数组。
```

**法三merge sort从后向前**
```
时间复杂度：O(m+n)
指针移动单调递减，最多移动 m+n 次，因此时间复杂度为 O(m+n)

空间复杂度：O(1)
直接对数组 nums1 原地修改，不需要额外空间。
```

## 答案：
**法一**
```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        ####
        nums1[m:] = nums2
        nums1.sort()

```

**法二**
```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """

        temp = [0]*(m + n)
        left_index = 0
        right_index = 0
        index = 0
        
        while left_index < m and right_index < n:
            if nums1[left_index] <= nums2[right_index]:
                temp[index] = nums1[left_index]
                left_index += 1
                index += 1
            else:
                temp[index] = nums2[right_index]
                right_index += 1
                index +=1
                
        while left_index < m:
            temp[index] = nums1[left_index]
            left_index += 1
            index += 1
        while right_index < n:
            temp[index] = nums2[right_index]
            right_index += 1
            index +=1
            
        for i in range(0, m + n):
            nums1[i] = temp[i]


```

**法三**
```python


```
