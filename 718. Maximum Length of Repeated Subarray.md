## 题目：718. Maximum Length of Repeated Subarray

https://leetcode.com/problems/maximum-length-of-repeated-subarray/

Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.

```
Example 1:

Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
Output: 3
Explanation: The repeated subarray with maximum length is [3,2,1].
Example 2:

Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
Output: 5
 

Constraints:

1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 100
```



## 答案：
**DP*
```python
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        
         ## DP
     ##并且通常都定义 dp[i][j] 为 以 A[i], B[j] 结尾的 xxx。
     ##这道题就是：以 A[i], B[j] 结尾的两个数组中公共的、长度最长的子数组的长度。
     ##如果 A[i] == B[j]，dp[i][j] = dp[i - 1][j - 1] + 1否则，dp[i][j] = 0

        m, n = len(nums1), len(nums2)
        res = 0
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if nums1[i - 1] == nums2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                    res = max(res, dp[i][j])
        return res

#时间和空间都为O(m*n)
```

**sliding windoe*
```python
      
        #滑动窗口
        #我们可以枚举 A 和 B 所有的对齐方式。
        #对齐的方式有两类：第一类为nums2不变，num1的某个元素和nums2对齐
        ##第二类#nums1不变，num2的某个元素和nums1对齐。对于每一种对齐方式，我们计算它们相对位置相同的重复子数组即可。
        def maxLength(a,  b, length) -> int:
            #a,b 分别是nums1,2开始对齐的位置
            res = 0
            cur = 0
            for i in range(length):
                if nums1[a + i] == nums2[b + i]:
                    cur += 1
                    res = max(res, cur)
                else:
                    cur = 0
            return res
        
        m, n = len(nums1), len(nums2)
        res = 0
        for i in range(m):#nums2不变，num1的某个元素和nums2对齐
            length = min(n, m - i)
            res = max(res, maxLength(i, 0, length))
        for i in range(n):#nums1不变，num2的某个元素和nums1对齐
            length = min(m, n - i)
            res = max(res, maxLength(0, i, length))
        return res
#时间复杂度： O((N+M)×min(N,M))。

#空间复杂度： O(1)。

```

## 思路：718
**DP**
![a](https://github.com/SSRRBB/Leetcode/blob/main/Images/447.png)
**sliding windwo
```
  #我们可以枚举 A 和 B 所有的对齐方式。
        #对齐的方式有两类：第一类为nums2不变，num1的某个元素和nums2对齐
        ##第二类#nums1不变，num2的某个元素和nums1对齐。对于每一种对齐方式，我们计算它们相对位置相同的重复子数组即可。

```
