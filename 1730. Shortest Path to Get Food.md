## 题目：1730. Shortest Path to Get Food
You are starving and you want to eat food as quickly as possible. You want to find the shortest path to arrive at any food cell.

You are given an m x n character matrix, grid, of these different types of cells:

'*' is your location. There is exactly one '*' cell.
'#' is a food cell. There may be multiple food cells.
'O' is free space, and you can travel through these cells.
'X' is an obstacle, and you cannot travel through these cells.
You can travel to any adjacent cell north, east, south, or west of your current location if there is not an obstacle.

Return the length of the shortest path for you to reach any food cell. If there is no path for you to reach food, return -1.

Constraints:
```
m == grid.length
n == grid[i].length
1 <= m, n <= 200
grid[row][col] is '*', 'X', 'O', or '#'.
The grid contains exactly one '*'.
```
## 思路：
BFS（参考一下numbers of island）

## 答案：
```python
class Solution:
    def getFood(self, grid: List[List[str]]) -> int:
         # Get parameters
        rows = len(grid)
        cols = len(grid[0])
        directions = [(0, -1), (0, 1), (1, 0), (-1,0)]
        visited = set()

        # Find the start cell
        for row in range(rows):
            for col in range(cols):
                if grid[row][col] == '*':
                    start_row = row
                    start_col = col
                    break
        # Initialization for Breadth First Search
        steps = 0
        queue = deque([(start_row, start_col, steps)])
        visited.add((start_row, start_col))

        # Start BFS traverse
        while queue:
            
            # Get the current state and steps
            curr_row, curr_col, steps = queue.popleft()

            # If it found a pizza, return the number of steps so far.
            # This steps is guaranteed to be the minimum steps because we use BFS
            if grid[curr_row][curr_col] == '#':
                return steps

            # We haven’t found a pizza yet, so go to another cell to find it
            for dx, dy in directions:
                next_row = curr_row + dx
                next_col = curr_col + dy

                # We can go if the next cell is in the grid, a free space, not visited yet, and either a free space or pizza place
                if 0 <= next_row < rows and 0 <= next_col < cols and grid[next_row][next_col]!= 'X' and (next_row, next_col) not in visited:
                    queue.append((next_row, next_col, steps + 1))
                    visited.add((next_row, next_col))

        # Otherwise, it wasn’t able to find a pizza, meaning no parth to find the pizza so return -1
        return -1
```
```python
## bfs level transverse
        rows = len(grid)
        cols = len(grid[0])
        directions = [(0, -1), (0, 1), (1, 0), (-1,0)]
        seen = set()
        
        #1 .find the person
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == '*':
                    start_r = r
                    start_c = c
                    break
        
        res = 0
        deque = collections.deque([(start_r, start_c)])
        seen.add((start_r, start_c))
        while deque:
            size = len(deque)
            # we only need finish the search at current level 
            # then go to next level
            for _ in range(size):
                currR, currC = deque.popleft()
                # 2. reach the pizza
                if grid[currR][currC] == '#':
                    return res

                for dx, dy in directions:
                    x = currR + dx
                    y = currC + dy

                    if 0 <= x < rows and 0 <= y < cols and grid[x][y] != 'X' and (x,y) not in seen:
                        deque.append((x,y))
                        seen.add((x,y))
            res += 1
        
        return -1
```

![a](https://github.com/SSRRBB/Leetcode/blob/main/Images/410.png)
