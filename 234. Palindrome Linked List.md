## 题目：https://leetcode.com/problems/palindrome-linked-list/


## 思路：
**方法一**
```
linklist 的val加入到list中，然后再判断
直接reverse 或者双指针
时间和空间都为O(n)
```
**方法一**
```
结合 206 + 876
分成前后两部分
然后后部分反转
比较前部分和反转后的后部分
时间 0(n)
空间 O(1)
```

## 答案：
**方法一**
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        val_list = []
        cur = head
        while cur:
            val_list.append(cur.val)
            cur = cur.next
        # return val_list == val_list[::-1]
        left, right = 0, len(val_list) - 1
        while left < right:
            if val_list[left] != val_list[right]:
                return False
            else:
                left += 1
                right -= 1
        return True

```

**方法二**
```python


```
